const https = require("follow-redirects").https;

const utils = require("./utils");

let lastRequestTime = null;
let fetchInterval = null;

function getCoordinates(dep, version, confType) {
  if (!version) return false;
  const tag = `${dep}@${version.match(/(\d+\.)?(\d+\.)?(\*|\d+)/)[0]}`;
  switch (confType) {
    case "javascript":
      return `pkg:npm/${tag}`;
    case "rust":
      return `pkg:cargo/${tag}`;
    case "python:requirements":
    case "python:pipfile":
    case "python:pyproject":
      return `pkg:pypi/${tag}`;
    default:
      return false;
  }
}

function filterPackagesToCheck(depList, confType) {
  const filteredList = [];
  for (let dep of depList) {
    const info = global.store.get(confType, dep);
    if (!("vulnerabilities" in info)) {
      const coordinate = getCoordinates(dep, info.current_version, confType);
      if (coordinate) filteredList.push(coordinate);
    }
  }
  return filteredList;
}

function populateVulnerability(data, confType) {
  for (let p of data) {
    // TODO: might have issues with pacages with namespace
    const dep = p.coordinates.split("/")[1].split("@")[0];
    global.store.set(confType, dep, { vulnerabilities: p.vulnerabilities });
  }
}

function updateVulnerabilities(depList, confType) {
  if (fetchInterval) clearInterval(fetchInterval);
  fetchInterval = setInterval(
    () => {
      const searchList = filterPackagesToCheck(depList, confType).splice(0, 199);
      if (searchList.length === 0) clearInterval(fetchInterval);

      const data = JSON.stringify({ coordinates: searchList });
      const options = {
        hostname: "ossindex.sonatype.org",
        port: 443,
        path: "/api/v3/component-report",
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Content-Length": data.length,
        },
      };

      let req = https
        .request(options, resp => {
          let data = "";
          resp.on("data", chunk => {
            data += chunk;
          });
          resp.on("end", () => {
            const parsed = JSON.parse(data);
            populateVulnerability(parsed, confType);
          });
        })
        .on("error", err => {
          console.log("Error: " + err.message);
        });

      req.write(data);
      req.end();
    },

    lastRequestTime === null ? 0 : 3000
  );
  lastRequestTime = new Date().getTime();
}

async function showVulnerabilities(handle) {
  const filePath = await handle.nvim.commandOutput("echo expand('%')"); // there should be a better, I just don't know
  const confType = utils.determineFileKind(filePath);
  const nameRegex = utils.getNameRegex(confType);

  const line = await handle.nvim.getLine();

  const vals = line.match(nameRegex);
  if (vals !== null && vals !== undefined && 1 in vals && vals[1] !== null) {
    const dep = vals[1].trim();
    const info = global.store.get(confType, dep);
    if (!("vulnerabilities" in info)) {
      await handle.nvim.command('echo "No vulnerabilities found"');
      return;
    }
    const vulnerability_info = utils.createVulStats(
      info.vulnerabilities,
      `${dep}@${info.current_version}`
    );

    await handle.nvim.command("topleft new");
    await handle.nvim.command("set ft=markdown");
    await handle.nvim.buffer.insert(vulnerability_info, 0);
    [
      "nobuflisted",
      "nolist",
      "bufhidden=wipe",
      "setlocal buftype=nofile",
      "setlocal bufhidden=hide",
    ].map(async c => {
      await handle.nvim.command(c);
    });
  }
}

module.exports = { updateVulnerabilities, showVulnerabilities };
